		         +---------------------------+
                         |  SISTEMAS DISTRIBUIDOS    |
                         |  TP RPC C VERUS ERLANG    |
                         | 	  RELATORIO          |
                         +---------------------------+

---- GROUP ----

Luiz Fernando Martins de Carvalho <luiz.uo@gmail.com>
Felipe

---- PRELIMINARIES ----

>> Introducao

Este TP tem como objetivo fazer um programa que transfira um arquivo de um servidor para um cliente RPC utilizando {10 bytes, 1kb, 100kb, 1Mb}, 2 clientes, 4 clientes simultÃ¢neos.

>> Intrucoes

Ajustar o caminho do arquivo "TEST.txt" dentro do arquivo fonte "server.c"

Para compilar, apenas rode o comando "make"
Para limpar, execute o comando "make clean"

Para rodar o servidor execute: "./server"
Para rodar o cliente execute: "./client <HOST> <TAMANHO>", onde HOST e o local do servidor e TAMANHO eh o tamanho a ser lido do arquivo TEST.txt

>> Referencias

Exemplos de RPC via C e Erlang
https://pdincau.wordpress.com/category/c/

Enviando o conteudo de um arquivo via C RPC
http://tufangorel.blogspot.com.br/2009/04/passing-multiple-parameters-with-rpcgen.html

Envinado Strig pelo RPC
http://stackoverflow.com/questions/28822436/passing-character-pointers-from-client-to-server-in-rpcgen

                                 JOIN
                                 ====

---- DATA STRUCTURES ----

Estrutura para informar o tamanho do arquivo a ser lido pelo servidor e tambem para guardar o conteudo do arquivo a ser enviado para o cliente

   /* tp_info */
   struct tp_info {
        int size;
        name data;
    };

---- ALGORITHMS ----

Servidor:

char **tp_proc_1_svc(tp_info *in, struct svc_req *rqstp): Funcao que le o arquivo TXT e envia para o cliente o conteudo solicitado
void *tp_exit_1_svc(struct tp_info *in, struct svc_req *rqstp): Funcao que termina o servidor e retorna para o cliente

Cliente:
int main(): Executa a solicitacao de leitura do arquivo do servidor e retorna a quantiadde de bytes lidos e imprime na tela o conteudo do arquivo.

---- RESULTADOS ----

1)O algoritmo leu com sucesso 10 bytes, 1kb via UDP porem so conseguiu ler aquivos de 100kb, 1Mb via TCP.

Ao executar com dois clientes tambem tivemos o mesmo resultado, possivelmente se ajustado para suportar um dado maior teriamos um comportamente de perfomance mais lento ao execuar com 4 clientes.

2)Se a conexao cair toda a mensagem sera perdida, o cliente tera de solicatar uma nova leitura ao servidor.

3)Na conexao UDP temos uma transferencia mais veloz, porem nao ha garantia de recebimento. Alem disso quando enviamos via UDP existe um limite bem pequeno para o tamanho do dado enviado. Somente conseguiu ler 10 bytes, 1kb.

Na conexao TCP existe a garantia do recebimendo em detrimento da velocidade. O TCP suportou todos os tamanhos de dados: 10 bytes, 1kb, 100kb, 1Mb

4) Comparar com o codigo Erlang: O codigo Erlang foi muito mais simples, o Erlang eh uma liguagem adaptada a transferncia de mensagens, ele suportaria um volume maior de dados e tambem ele eh mais tolerante a falhas. O Erlang eh nativametne acincrono o que torna todo o processo de comunicacao e chamada de funcoes remotas muito mais simples e pratico.




